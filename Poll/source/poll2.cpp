// poll2.cpp
// Cory R. Thornsberry
// Jan. 21st, 2015
//
// This program is designed as a replacement of the POLL program for reading
// VANDLE data from PIXIE-16 crates. The old POLL program relied on a connection
// to PACMAN in order to recieve commands whereas this is a stand-alone program
// with a built-in command line interface. The .ldf file format is retained, but
// this program does not split buffers to fit into the HRIBF standard buffer.
// Data is also not transmitted onto a socket (except for shm). Instead, .ldf
// files are generated by this program directly.

#include <iostream>
#include <thread>
#include <utility>
#include <map>

#include "poll2_core.h"
#include "Display.h"
#include "StatsHandler.hpp"

#ifndef USE_NCURSES

#include <termios.h>

/* Reset the terminal attributes to normal. */
void restore_terminal(){
	tcsetattr(STDIN_FILENO, TCSANOW, &SAVED_ATTRIBUTES);
}

/* Take control of the terminal to capture user input. */
bool takeover_terminal(){
	struct termios tattr;
	char *name;

	/* Make sure stdin is a terminal. */
	if(!isatty (STDIN_FILENO)){
		fprintf (stderr, "Not a terminal.\n");
		return false;
	}

	/* Save the terminal attributes so we can restore them later. */
	tcgetattr(STDIN_FILENO, &SAVED_ATTRIBUTES);

	/* Set the terminal modes. */
	tcgetattr(STDIN_FILENO, &tattr);
	tattr.c_cc[VMIN] = 1;
	tattr.c_cc[VTIME] = 0;
	if(tcsetattr(STDIN_FILENO, TCSAFLUSH, &tattr) == 0){ return true;  }	
	return false;
}

#endif
	
/* Print help dialogue for command line options. */
void help(){
	std::cout << "\n SYNTAX: ./poll2 [options]\n";
	std::cout << "  -a, --alarm=[e-mail] Call the alarm script with a given e-mail (or no argument)\n"; 
	std::cout << "  -f, --fast           Fast boot (false by default)\n";
	std::cout << "  -h, --hist <num>     Dump histogram data every num seconds\n";
	std::cout << "  -q, --quiet          Run quietly (false by default)\n";
	std::cout << "  -n, --no-wall-clock  Do not insert the wall clock in the data stream\n";
	std::cout << "  -r, --rates          Display module rates in quiet mode (false by defualt)\n";
	std::cout << "  -s, --stats <num>    Output statistics data every num seconds\n";
	std::cout << "  -t, --thresh <num>   Sets FIFO read threshold to num% full (50% by default)\n";
	std::cout << "  -z, --zero           Zero clocks on each START_ACQ (false by default)\n";
	std::cout << "  -d, --debug          Set debug mode to true (false by default)\n";
	std::cout << "  -m, --memory-share   Do not write data to shared memory (SHM) (true by default)\n\n";
}	
	
void start_run_control(Poll *poll_){
	poll_->run_control();
}

void start_cmd_control(Poll *poll_, Terminal *term_){
	poll_->command_control(term_);
}

int main(int argc, char *argv[]){
#ifdef USE_NCURSES
	Terminal poll_term;
#else
	struct termios SAVED_ATTRIBUTES;
#endif

	// Read the FIFO when it is this full
	unsigned int threshPercent = 50;
	std::string alarmArgument = "";

	//We make sure the system isn't locked first.
	// This avoids issues with curses.
	Lock *lock = new Lock("PixieInterface");
	delete lock;

	// Main object
	Poll poll;

	// Define all valid command line options
	// This is done to keep legacy options available while removing dependency on HRIBF libraries
	CLoption valid_opt[12];
	valid_opt[0].Set("alarm", false, true);
	valid_opt[1].Set("fast", false, false);
	valid_opt[2].Set("hist", true, false);
	valid_opt[3].Set("quiet", false, false);
	valid_opt[4].Set("no-wall-clock", false, false);
	valid_opt[5].Set("rates", false, false);
	valid_opt[6].Set("stats", true, false);
	valid_opt[7].Set("thresh", true, false);
	valid_opt[8].Set("zero", false, false);
	valid_opt[9].Set("debug", false, false);
	valid_opt[10].Set("memory-share", false, false);
	valid_opt[11].Set("?", false, false);
	if(!get_opt(argc, argv, valid_opt, 12, help)){ return EXIT_FAILURE; }
	
	// Set all of the selected options
	if(valid_opt[0].is_active){
		if(valid_opt[0].value != ""){ alarmArgument = valid_opt[0].value; }
		poll.SEND_ALARM = true;
	}
	if(valid_opt[1].is_active){ poll.BOOT_FAST = true; }
	if(valid_opt[2].is_active){ 
		poll.HISTO_INTERVAL = atoi(valid_opt[2].value.c_str()); 
		if(poll.HISTO_INTERVAL <= 0){ 
			std::cout << "Warning! failed to set histogram interval. Using default of 10s\n";
			poll.HISTO_INTERVAL = 10; 
		}
	}
	if(valid_opt[3].is_active){ poll.IS_QUIET = true; }
	if(valid_opt[4].is_active){ poll.INSERT_WALL_CLOCK = false; }
	if(valid_opt[5].is_active){ poll.SHOW_MODULE_RATES = true; }
	if(valid_opt[6].is_active){ 
		poll.STATS_INTERVAL = atoi(valid_opt[6].value.c_str()); 
		if(poll.STATS_INTERVAL <= 0){ 
			std::cout << "Warning! failed to set statistics interval. Using default of 10s\n";
			poll.STATS_INTERVAL = 10; 
		}
	}
	if(valid_opt[7].is_active){ 
		threshPercent = atoi(valid_opt[7].value.c_str()); 
		if(threshPercent <= 0){ 
			std::cout << "Warning! failed to set threshold level. Using default of 50%\n";
			threshPercent = 50; 
		}
	}
	if(valid_opt[8].is_active){ poll.ZERO_CLOCKS = true; }
	if(valid_opt[9].is_active){ poll.DEBUG_MODE = true; }
	if(valid_opt[10].is_active){ poll.SHM_MODE = false; }
	if(valid_opt[11].is_active){ return EXIT_SUCCESS; }

	if(!poll.initialize()){ return EXIT_FAILURE; }

#ifdef USE_NCURSES
	// Initialize the terminal before doing anything else;
	poll_term.Initialize(".poll2.cmd");
	poll_term.SetPrompt("POLL2 $ ");
#endif

	std::cout << "\n#########      #####    ####      ####       ########\n"; 
	std::cout << " ##     ##    ##   ##    ##        ##       ##      ##\n";
	std::cout << " ##      ##  ##     ##   ##        ##                ##\n";
	std::cout << " ##     ##  ##       ##  ##        ##               ##\n";
	std::cout << " #######    ##       ##  ##        ##              ##\n";
	std::cout << " ##         ##       ##  ##        ##            ##\n";
	std::cout << " ##         ##       ##  ##        ##           ##\n";
	std::cout << " ##          ##     ##   ##        ##         ##\n";
	std::cout << " ##           ##   ##    ##    ##  ##    ##  ##\n";
	std::cout << "####           #####    ######### ######### ###########\n";

	std::cout << "\n POLL2 v" << POLL_VERSION << "\n"; 
	std::cout << " ==  ==  ==  ==  == \n\n"; 
	
	poll.threshWords = EXTERNAL_FIFO_LENGTH * threshPercent / 100;
	std::cout << "Using FIFO threshold of " << poll.threshWords << " words\n";

#ifndef USE_NCURSES
	// Take control of the terminal
	std::cout << pad_string("Taking control of the terminal", 49);
	if(takeover_terminal()){ std::cout << Display::OkayStr() << std::endl; }
	else{ 
		std::cout << Display::ErrorStr() << std::endl; 
		return EXIT_FAILURE;
	}
#endif
  
  	StatsHandler handler(poll.N_CARDS);
  	if(poll.STATS_INTERVAL > 0){ poll.set_stat_handler(&handler); }

	if(poll.SEND_ALARM){
		Display::LeaderPrint("Sending alarms to");
		if(alarmArgument.empty()){ std::cout << Display::InfoStr("DEFAULT") << std::endl; }
		else { std::cout << Display::WarningStr(alarmArgument) << std::endl; }
	}

	// Start the run control thread
	std::cout << pad_string("Starting run control thread", 49);
	std::thread runctrl(start_run_control, &poll);
	std::cout << Display::OkayStr() << std::endl;

	// Start the command control thread. This needs to be the last thing we do to
	// initialize, so the user cannot enter commands before setup is complete
	std::cout << pad_string("Starting command thread", 49);
	std::thread comctrl(start_cmd_control, &poll, &poll_term);
	std::cout << Display::OkayStr() << std::endl << std::endl;
	
	// Synchronize the threads and wait for completion
	comctrl.join();
	runctrl.join();

	// Close the output file, if one is open
	poll.close_output_file();

#ifdef USE_NCURSES

	poll_term.Close();
	//Reprint the leader as the carriage was returned
	Display::LeaderPrint(std::string("Running poll2 v").append(POLL_VERSION));
	std::cout << Display::OkayStr("[Done]") << std::endl;
	
#else

	restore_terminal();
	
#endif

	return EXIT_SUCCESS;
}
