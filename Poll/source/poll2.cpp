// poll2.cpp
// Cory R. Thornsberry
// Jan. 21st, 2015
//
// This program is designed as a replacement of the POLL program for reading
// VANDLE data from PIXIE-16 crates. The old POLL program relied on a connection
// to PACMAN in order to recieve commands whereas this is a stand-alone program
// with a built-in command line interface. The .ldf file format is retained, but
// this program does not split buffers to fit into the HRIBF standard buffer.
// Data is also not transmitted onto a socket (except for shm). Instead, .ldf
// files are generated by this program directly.

#include <iostream>
#include <thread>
#include <utility>
#include <map>

#include "poll2_core.h"
#include "Display.h"
#include "StatsHandler.hpp"

PixieInterface pif("pixie.cfg");

void start_run_control(Poll *poll_){
	poll_->run_control();
}

void start_cmd_control(Poll *poll_){
	poll_->command_control();
}

int main(int argc,char *argv[]){
	std::cout << "\n#########      #####    ####      ####       ########\n"; 
	std::cout << " ##     ##    ##   ##    ##        ##       ##      ##\n";
	std::cout << " ##      ##  ##     ##   ##        ##                ##\n";
	std::cout << " ##     ##  ##       ##  ##        ##               ##\n";
	std::cout << " #######    ##       ##  ##        ##              ##\n";
	std::cout << " ##         ##       ##  ##        ##            ##\n";
	std::cout << " ##         ##       ##  ##        ##           ##\n";
	std::cout << " ##          ##     ##   ##        ##         ##\n";
	std::cout << " ##           ##   ##    ##    ##  ##    ##  ##\n";
	std::cout << "####           #####    ######### ######### ###########\n";

	std::cout << "\n POLL2 v" << POLL_VERSION << "\n"; 
	std::cout << " ==  ==  ==  ==  == \n\n"; 

	// Read the FIFO when it is this full
	unsigned int threshPercent = 50;
	std::string alarmArgument = "";

	// Main object
	Poll poll;

	// Define all valid command line options
	// This is done to keep legacy options available while removing dependency on HRIBF libraries
	CLoption valid_opt[12];
	valid_opt[0].Set("alarm", false, true);
	valid_opt[1].Set("fast", false, false);
	valid_opt[2].Set("hist", true, false);
	valid_opt[3].Set("quiet", false, false);
	valid_opt[4].Set("no-wall-clock", false, false);
	valid_opt[5].Set("rates", false, false);
	valid_opt[6].Set("stats", true, false);
	valid_opt[7].Set("thresh", true, false);
	valid_opt[8].Set("zero", false, false);
	valid_opt[9].Set("debug", false, false);
	valid_opt[10].Set("memory-share", false, false);
	valid_opt[11].Set("?", false, false);
	if(!get_opt(argc, argv, valid_opt, 12)){ return EXIT_FAILURE; }
	
	// Set all of the selected options
	if(valid_opt[0].is_active){
		if(valid_opt[0].value != ""){ alarmArgument = valid_opt[0].value; }
		poll.SEND_ALARM = true;
	}
	if(valid_opt[1].is_active){ poll.BOOT_FAST = true; }
	if(valid_opt[2].is_active){ 
		poll.HISTO_INTERVAL = atoi(valid_opt[2].value.c_str()); 
		if(poll.HISTO_INTERVAL <= 0){ 
			std::cout << "Warning! failed to set histogram interval. Using default of 10s\n";
			poll.HISTO_INTERVAL = 10; 
		}
	}
	if(valid_opt[3].is_active){ poll.IS_QUIET = true; }
	if(valid_opt[4].is_active){ poll.INSERT_WALL_CLOCK = false; }
	if(valid_opt[5].is_active){ poll.SHOW_MODULE_RATES = true; }
	if(valid_opt[6].is_active){ 
		poll.STATS_INTERVAL = atoi(valid_opt[6].value.c_str()); 
		if(poll.STATS_INTERVAL <= 0){ 
			std::cout << "Warning! failed to set statistics interval. Using default of 10s\n";
			poll.STATS_INTERVAL = 10; 
		}
	}
	if(valid_opt[7].is_active){ 
		threshPercent = atoi(valid_opt[7].value.c_str()); 
		if(threshPercent <= 0){ 
			std::cout << "Warning! failed to set threshold level. Using default of 50%\n";
			threshPercent = 50; 
		}
	}
	if(valid_opt[8].is_active){ poll.ZERO_CLOCKS = true; }
	if(valid_opt[9].is_active){ poll.DEBUG_MODE = true; }
	if(valid_opt[10].is_active){ poll.SHM_MODE = false; }
	if(valid_opt[11].is_active){ return EXIT_SUCCESS; }
		
	poll.threshWords = EXTERNAL_FIFO_LENGTH * threshPercent / 100;
	std::cout << "Using FIFO threshold of " << poll.threshWords << " words\n";

	// Take control of the terminal
	std::cout << pad_string("Taking control of the terminal", 49);
	if(poll.takeover_terminal()){ std::cout << Display::OkayStr() << std::endl; }
	else{ 
		std::cout << Display::ErrorStr() << std::endl; 
		return EXIT_FAILURE;
	}
  
  	poll.initialize();
  	StatsHandler handler(poll.N_CARDS);
  	if(poll.STATS_INTERVAL > 0){ poll.set_stat_handler(&handler); }

	if(poll.SEND_ALARM){
		Display::LeaderPrint("Sending alarms to");
		if(alarmArgument.empty()){ std::cout << Display::InfoStr("DEFAULT") << std::endl; }
		else { std::cout << Display::WarningStr(alarmArgument) << std::endl; }
	}

	// Start the run control thread
	std::cout << pad_string("Starting run control thread", 49);
	std::thread runctrl(start_run_control, &poll);
	std::cout << Display::OkayStr() << std::endl;
 
	// Start the command control thread. This needs to be the last thing we do to
	// initialize, so the user cannot enter commands before setup is complete
	std::cout << pad_string("Starting command thread", 49);
	std::thread comctrl(start_cmd_control, &poll);
	std::cout << Display::OkayStr() << std::endl << std::endl;
	
	// Synchronize the threads and wait for completion
	comctrl.join();
	runctrl.join();

	// Close the output file, if one is open
	poll.close_output_file();

	exit(EXIT_SUCCESS);
}
